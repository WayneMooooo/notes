# DMSTC

## abstract

Complete Path Planning (CPP) is essential for robotic tasks such as vacuum cleaning, lawn mowing, and search and rescue operations,


## Introduction

Complete path planning <mark>[enric]</mark> is the task to determine a path that covers all points of an area of interest,either by physical contact or sensor detection, while avoiding obstacles and optimizing the travel time, processing speed, cost energy, and so on.CPP has many robotic applications such as vacuum cleaning robot<mark>[Viet]</mark>Ôºålawn mowing<mark>[Schirmer]</mark>,mine countermeasures<mark>[Morin]</mark>, structure inspection<mark>[Jing]</mark>, agriculture<mark>[Maini]</mark>, marine surveying and mapping<mark>[Ma]</mark>, search and rescue operation<mark>Ai</mark>.

In recent decades, researchers have devoted considerable attention to CPP, yielding numerous and effective methods. Within this domain, the single robot coverage planning problem has seen the development of several mature methods. These include cellular decomposition[Choset,Coombes], spanning tree coverage[Gabriely], graph-based coverage[Le], dynamic programming based coverage[Morin], and hex-decomposition-based coverage[Kan].

The use of multi-robot teams in coverage path planning (forming the mCPP problem) significantly enhances operational efficiency and reduces the time required for complete coverage, particularly in large or complex environments. A critical aspect and challenge of mCPP lies in how coverage tasks are distributed among the robots. Current research indicates that existing methods struggle with uneven coverage speeds within these systems. Tasks are typically statically assigned to each robot and then executed, which may appear balanced initially. However, disparities in actual coverage performance, such as differences in coverage speed or the varying times required to cover different areas, prevent the multi-robot system from maximizing its potential effectiveness.

This paper presents a novel algorithm named Multi-robot Dynamic Spanning Tree Coverage (MDSTC) to address the issue of real-time imbalances in mCPP.  We treat mCPP as the problem of dividing the operational area into sub-areas, with each sub-area assigned to a single robot for independent coverage. To find a well-balanced division of regions, MDSTC initially conducts a rough partitioning of the area and subsequently adjusts the divisions iteratively through an exchange-based mechanism. For single robot coverage within sub-areas, we propose a variant of the Spanning Tree Coverage (STC) method, namely Dynamic Spanning Tree Coverage (DSTC). DSTC plans coverage incrementally while constructing a spanning tree and executing the path, allowing reserved unplanned areas for dynamic adjustments by MDSTC. Our algorithm is an online mCPP solution that can make timely adjustments in response to imbalances that arise during the execution of coverage tasks by multiple robots. The proposed method is evaluated in simulations featuring dynamic imbalance scenarios, and further tests are also designed to demonstrate other performance capabilities of the algorithm.


## Related Work

Among various single-robot coverage methods, Spanning Tree Coverage (STC) has demonstrated superior performance, regardless of the robot's initial position and the distribution of obstacles. STC is a cell-decomposition-based method that first computes the spanning tree of the cell graph, and then the robot circumnavigating the spanning tree. Figure 1 illustrates an example of STC. Building on STC, several methods have been proposed to tackle the multi-robot coverage path planning problem. Hazon and Kaminka first introduced a solution named MSTC for mCPP based on the STC algorithm, which efficiently handles robot failure by splitting the entire STC path based on the robots' initial positions [hazon]. However, this method heavily depends on the robots' initial placement and the construction of the spanning tree. To improve balance and enhance coverage efficiency, Zheng et al. proposed the Multirobot Forest Coverage (MFC) method, which constructs a forest of trees, one for each robot, thereby improving overall efficiency [zheng]. This method has proven effective even in environments with complex obstacles and maintains a polynomial computational complexity. In pursuit of online efficiency, Senthilkumar and Bharadwaj introduced an online algorithm that constructs the spanning tree simultaneously, performing effectively in environments without prior knowledge and achieving a high coverage rate [Senthilkumar]. Dong et al. proposed the AWSTC algorithm as a suitable solution for multi-UAV area coverage in a distributed manner, where each robot concurrently constructs a spanning tree directed toward the center of inertia of the uncovered area [dong, Chleboun]. Additionally, the authors conducted physical experiments in a controlled environment, without unexpected obstacles. Recently, Kapoutsis et al. introduced a divide-area algorithm named DARP to pursue an optimal coverage solution for mCPP [Kapoutsis, Gao, Xin, Idir]. This method divides the concerned area among robots, with each robot constructing an STC path within its designated area. DARP reduces the mCPP problem to multiple single-robot CPP problems through area division.

In view of the aforementioned works, the proposed approaches effectively solve the mCPP problem for static environments, balancing efficiency and equity.These methods are well-suited for multi-robot systems with good balanceÔºõhowever, as aforementioned, multi-robot systems in actual operation may not be as balanced as anticipated, and environmental factors may cause disparities in operational efficiency among robots.  In response to these challenges, our approach incorporates considerations for such disparities, proposing a dynamic solution to address the imbalance issues within mCPP.


## Problem Formulation

The mCPP (multi-robot Coverage Path Planning) problem typically involves $r$ robots, each equipped with sensing tools such as cameras and radars, capable of covering a square region of size $D$. This size is chosen to be at least larger than the robot's own dimensions. The target environment, $\mathbb{A} \subset \mathbb{R}^2$, is a bounded planar area with a finite number of known obstacles. Given the coverage capability $D$ of the robots, the environment $\mathbb{A}$ is structured into a grid region $\mathcal{G}$ using methods like cell decomposition or grid-based approaches. This grid is composed of $2D$-size cells, each of which is formed by assembling four $D$-size cells. For notational simplicity, these $2D$-size cells are simply called *cells*, while $D$-size cells are termed *subcells*. Some cells are identified as occupied, containing obstacles or impassable areas, and collectively form the set $\mathcal{B}$. The remaining cells are classified as free and make up the set $\mathcal{L}$, representing navigable areas that need coverage by at least one robot. An example of this environmental decomposition is shown in Figure 1, where gray grids depict occupied cells, and light-colored grids represent free cells.
 
The solution to the mCPP problem comprises a series of grid sequence paths $X_i\forall i\in\{1,\cdots,r\}$ for each robot $i$, beginning at the robots' initial positions. Each path is assigned to a specific robot, and the free cells in the grid region $G$ are included in at least one of these paths. The optimization objective is as follows::

$$\begin{array}{l}
\underset{X}{\operatorname{minimize}} \max _{i \in\left\{1, \ldots, r\right\}}\left|X_{i}\right| \\
\text { s.t. }~ X_{1} \cup X_{2} \cup \cdots \cup X_{r} \supseteq \mathcal{L}
\end{array}$$
where $|X_i|$ represents the length of the path $X_i$. 

In this paper,  we focus on developing a mCPP solution that can adjust in real-time. This solution aims to minimize the total area coverage time of a multi-robot system, which is distinct from the workload-balancing objectives of standard mCPP. For this purpose, we define $W_i = \frac{|X_i|}{v_i} \forall i \in {1, \cdots, r}$ as the total time required for robot $i$ to complete its assigned coverage tasks, where $v_i$ is the speed of robot $i$. The problem can be formulated as follows:
$$\begin{array}{l}
\underset{X}{\operatorname{minimize}} \max _{i \in\left\{1, \ldots, r\right\}} W_{i} \\
W_i=\frac{|X_i|}{v_i}\forall i\in\{1,\cdots,r\}\\
\text { s.t. }~ X_{1} \cup X_{2} \cup \cdots \cup X_{r} \supseteq \mathcal{L}.
\end{array}$$

## Dynamic Spanning Tree Coverage

In this section, we introduce an online CPP algorithm named DSTC (Dynamic Spanning Tree Coverage), which is an variant version of the traditional Spiral-STC . This advanced algorithm is designed for a single robot but lays the groundwork for the subsequent multi-robot version, MDSTC. We introduce the concept of *sliding window* into the original STC algorithm. For a robot located at current position $p_{cur}$ within the covering graph $\mathcal{G}$, the *sliding window* is defined as a series of adjacent cells $\mathcal{G}_{window}$ that includes the cell containing $p_{cur}$. An example of a *sliding window* is illustrated in <mark>Fig. 2-(a)</mark>. The DSTC algorithm plans coverage for only a segment of the area within a planning cycle, rather than the entire region. It computes an STC path of *sliding window* area, outputting a segment of the path for the robot to execute. DSTC is an online CPP method.

We demonstrate the detailed process for DSTC in Algorithm 1. Starting with a covering graph $\mathcal{G}$ obtained through cell decomposition, the robot begins at the initial cell $p_{initial}$. Each planning cycle produces a window path $\mathcal{P}_{cur}$, with a length of $l$, and the remaining path, which is scheduled for future execution, is denoted as $\mathcal{P}_{rest}$. Within each planning cycle, DSTC extends a new sliding window $\mathcal{G}_{window}$ based on the robot's current position $p_{cur}$ and generates a Spiral-STC path $\mathcal{P}_{window}$ within it.

If the current $\mathcal{G}_{window}$ is not empty, indicating that there are free cells around the robot to construct an STC path $\mathcal{P}_{window}$, this path is then divided into two parts: one part serves as the path output for the current planning cycle $\mathcal{P}_{cur}$; the remaining part, after eliminating any redundant or inappropriate segments, is concatenated with the remaining path $\mathcal{P}_{rest}$ (as shown in <mark>Fig. 2-(b)</mark>). If $\mathcal{G}_{window}$ is empty, meaning that $p_{cur}$ is surrounded by occupied cells, DSTC will backtrack along $\mathcal{P}_{rest}$. During backtracking, if a free cell is detected, a new sliding window and a subsequent STC path $\mathcal{P}_{back}$ are generated. The path output for the current planning cycle $\mathcal{P}_{cur}$ consists of the backtracked segment of $\mathcal{P}_{rest}$ and a portion of $\mathcal{P}_{back}$, with the remaining part of $\mathcal{P}_{back}$ also being concatenated with $\mathcal{P}_{rest}$.

As described above, DSTC can be divided into two planning actions: Expanding and Backtracking. Expanding involves exploring free cells through the sliding window and computing the coverage path, while Backtracking involves completing the remainder of the previous path while looking for opportunities to extend a new sliding window. By repeatedly cycling through these two processes, DSTC can explore all the free cells and dynamically generate a series of paths that completely cover the area corresponding to $\mathcal{G}$. However, these paths are not necessarily non-backtracking because the DSTC algorithm, when expanding a new sliding window, frees the cell containing $p_{cur}$, potentially leading to overlapping sliding windows with a common cell. To address this issue, DSTC includes a step to delete paths in this common cell. However, in some cases(<mark>Fig. 2-(d)</mark>), to maintain the integrity of the path, we have opted to retain these overlapping paths.

Additionally, in each planning cycle, DSTC updates the content of $\mathcal{G}$ beyond the already planned cells based on the changes in the coverage area, such as the distribution of obstacles. Since not all cells are planned in one go, DSTC is capable of adapting to some dynamic changes in the coverage area $\mathcal{G}_{window}$ instead of undergoing complete replanning. This capability to adapt dynamically will be utilized in the subsequent resolution of multi-robot Coverage Path Planning (mCPP) problems.


<mark>Âä†ÂÖ•‰∏Ä‰∏™Âà§Êñ≠ËøáÁ®ãÔºåÂà§Êñ≠$\mathcal{G}_{window}$Êàñ$\mathcal{P}_{window}$ÊòØÂê¶‰∏∫Á©∫ÔºåÁÑ∂ÂêéÊåâÁÖßÊàëÂÜôÁöÑpythonÁ®ãÂ∫èÁöÑÊµÅÁ®ãÊù•‰øÆÊîπAlgoritm 1Ôºõ$\mathcal{G}_{window}$ÂåÖÂê´ÁöÑcell ÈÉΩÂæó‰ª§Êàêoccupied</mark>
![](https://raw.githubusercontent.com/WayneMooooo/notes/main/Â≠¶‰π†Á¨îËÆ∞/ÁÆóÊ≥ï/mcpp/dmstc.md/303884221240650.png)

## MULTIROBOT DYNAMIC SPANING-TREE COVERAGE

We now introduce MDSTC: a novel multi-robot coverage algorithm based on area division that dynamically adjusts task distribution to achieve the minimum global task completion time. MDSTC is composed of a region expansion algorithm and an exchange-based adjustment algorithm. Inspired by the approach of DARP [cite-DARP], which reduces the multi-robot scenario into *r* single-robot problems, MDSTC starts with a region expansion algorithm based on area division to segment the entire area into ùëü robot-exclusive subregions. Each robot then performs DSTC within its subregion. Concurrently, MDSTC adapts to the real-time coverage status of each robot and fine-tunes the subregions using the exchange-based adjustment algorithm to maximize the efficiency of the multi-robot system.

### Region Expansion

The certain environment is represented as a binary map $\mathcal{M}$, constructed through a cell decomposition based method. Within $\mathcal{M}$, cells that are occupied carry a value of 0, while free cells are marked with a value of 1.  The result of the area division is represented by the allocation matrix $A$. Once a cell is assigned to a robot, the corresponding value in $A$ is updated to that robot's identification number.

The region expansion algorithm operates as follows: The initial partition includes the cell corresponding to its assigned robot's starting position. Subsequently, each partition alternates expanding its territory within $\mathcal{M}$. The expansion of partitions ceases once all cells are allocated to a robot. The detailed process of the region expansion algorithm is described in Algorithm 2.  Partition of the $k_{th}$ robot expands by selecting a cell $\mathcal{M}(x,y)$ from its adjacent cell set $NL_k$‚Äã during its turn and marks it as $k$ in $A(x, y)$, indicating that the cell has been assigned to robot $k$.

Through the region expansion process, the coverage area is roughly divided into $r$ subregions. Each subregion $\mathcal{L}_i$‚Äã can be computed from the assignment matrix $A$ as follows:

$$\mathcal{L_i}=\{(x,y)\in\mathcal{L}:A(x,y)=i\},~\forall i\in\{1,\cdots,r\}.$$

<mark>Figure 5</mark> illustrates an example of the region expansion algorithm, in which each partition expand around its starting cells and the adjacent cells  are marked in gray. 

![](https://raw.githubusercontent.com/WayneMooooo/notes/main/Â≠¶‰π†Á¨îËÆ∞/ÁÆóÊ≥ï/mcpp/dmstc.md/159510116240653.png)

### Exchange-based Adjustment

By employing the region expansion algorithm, we obtain a rough solution for area division that allows robots to perform DSTC. While the robots execute DSTC within their respective subregions, an exchange-based adjustment algorithm is incorporated to achieve a balance in the multi-robot system.

As previously outlined, DSTC does not fully plan the entire area. Instead, it uses part of the free cells assigned to robots to generate paths for localized coverage. The remaining free cells are adjustable without compromising the connectivity of the subregions. Consider the scenario depicted in Figure 6, featuring two robots, $a$ and $b$, operating at identical speeds within their respective subregions of equal size. If, at a certain point, robot $b$ experiences a decrease in speed and becomes significantly slower than $a$, maintaining the original division of regions would undermine the system‚Äôs efficiency. In such a case, $a$ completes its assigned tasks while $b$ is still working on its area, which not only underutilizes $a$‚Äôs operational capacity but also delays the overall completion of the coverage task.

In Figure 6, the boundary cells that connect subregions $a$ and $b$ are free. If an appropriate portion of these boundary cells were reallocated from $b$ to $a$, the multi-robot system consisting of $a$ and $b$ could achieve quicker coverage time. Based on this concept, an exchange-based adjustment algorithm is introduced to balance the efficiency of the multi-robot coverage system, dynamically reallocating tasks to enhance overall system performance and reduce idle times. 

The exchange-based adjustment algorithm is detailed in Algorithm 3. Let $C$ denote the coverage matrix set that records the status of each free cell in the subregions. The sets of connected cells for $r$ partitions form $BL = {BL_1, \cdots, BL_r}$, where $BL_r$ comprises the set of cells of partition $\mathcal{L}_r$ that connect to another partition.

First, the exchange-based adjustment algorithm calculates the discrepancies between each robot's remaining tasks and the desired task allocations. The partition with the largest discrepancy is then designated as the donor, akin to robot $b$, and labeled as *start*. Conversely, the partition with the smallest discrepancy is chosen as the recipient, similar to robot $a$, and labeled as *dest*. If *start* and *dest* are adjacent, which means there are directly exchangeable cells between them,  they can swap through boundary cells. If *start* and *dest* are non-adjacent, a cell-exchange path needs to be established to enable indirect task swapping between them. The cell-exchange path is computed based on a graph in which vertices represent partitions, and the edge denotes that partitions at the end of the edge are adjacent. Once the cell-exchange path is determined, *start* and *dest* can swap free cells along this path. The exchange process repeats until the maximum discrepancy $|max(Dval_k)|$ meets a predefined threshold or the iteration count $n_{iter}$ reaches its limit.

![](https://raw.githubusercontent.com/WayneMooooo/notes/main/Â≠¶‰π†Á¨îËÆ∞/ÁÆóÊ≥ï/mcpp/dmstc.md/56994717259079.png)

### MDSTC Implementation

To summarize the process by which MDSTC solves the mCPP problem: Initially, the region expansion algorithm roughly divides the concerned area into $r$ partitions. Subsequently, each robot executes DSTC within its assigned subregion of the partition, covering the task area online. Simultaneously, the exchange-based adjustment algorithm adjusts task allocations based on the work status of each robot. Through this process, MDSTC allows the multi-robot system to dynamically and adjustably complete the coverage of the entire area. This procedure is illustrated in Figure 7.